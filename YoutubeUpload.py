import os
import logging
import tempfile
import subprocess
import asyncio
from pathlib import Path
from typing import Dict
from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.redis import RedisStorage
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.exceptions import TelegramBadRequest
from googleapiclient.discovery import build
from googleapiclient.http import MediaFileUpload
from google_auth_oauthlib.flow import InstalledAppFlow
from cryptography.fernet import Fernet

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
env_path = Path(__file__).parent / ".env"
load_dotenv(env_path)

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
REQUIRED_ENV = ["TELEGRAM_TOKEN", "REDIS_URL", "ENCRYPTION_KEY"]
if missing := [var for var in REQUIRED_ENV if not os.getenv(var)]:
    raise EnvironmentError(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {missing}")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
bot = Bot(token=os.getenv("TELEGRAM_TOKEN"))
storage = RedisStorage.from_url(os.getenv("REDIS_URL"))
dp = Dispatcher(storage=storage)
fernet = Fernet(os.getenv("ENCRYPTION_KEY").encode())


class UploadStates(StatesGroup):
    CONTENT_TYPE = State()
    MEDIA_UPLOAD = State()
    METADATA = State()
    VPN_CONFIG = State()
    PROXY = State()
    YOUTUBE_TOKEN = State()


async def get_user_data(user_id: int) -> Dict:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ Redis"""
    data = await storage.redis.hgetall(f"user:{user_id}")
    return {k.decode(): v.decode() for k, v in data.items()}


async def update_user_data(user_id: int, data: Dict) -> None:
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Redis"""
    await storage.redis.hmset(f"user:{user_id}", data)


@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    await message.answer(
        "üé• YouTube Upload Bot\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ /upload —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–≥—Ä—É–∑–∫—É",
        parse_mode="HTML"
    )


@dp.message(Command("upload"))
async def cmd_upload(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /upload"""
    await state.set_state(UploadStates.CONTENT_TYPE)
    await message.answer(
        "üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞:",
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üé• –í–∏–¥–µ–æ", callback_data="video")],
            [types.InlineKeyboardButton(text="üñºÔ∏è –ê—É–¥–∏–æ+–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", callback_data="audio_image")]
        ])
    )


@dp.callback_query(F.data.in_(["video", "audio_image"]))
async def content_type_handler(callback: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
    try:
        await state.update_data(content_type=callback.data)
        await callback.message.answer(
            "üì§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∏–¥–µ–æ —Ñ–∞–π–ª (MP4)" if callback.data == "video"
            else "üéµ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª (MP3)"
        )
        await state.set_state(UploadStates.MEDIA_UPLOAD)
        await callback.answer()
    except TelegramBadRequest as e:
        if "query is too old" in str(e):
            logger.warning(f"–ü—Ä–æ–ø—É—â–µ–Ω —É—Å—Ç–∞—Ä–µ–≤—à–∏–π –∑–∞–ø—Ä–æ—Å: {e}")
        else:
            raise


@dp.message(UploadStates.MEDIA_UPLOAD, F.video | F.audio | F.photo)
async def media_handler(message: types.Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–≤"""
    try:
        file_type = None
        path = None

        if message.video:
            file = await bot.get_file(message.video.file_id)
            ext = Path(file.file_path).suffix
            path = f"temp/{message.from_user.id}_video{ext}"
            file_type = "video"
        elif message.audio:
            file = await bot.get_file(message.audio.file_id)
            path = f"temp/{message.from_user.id}_audio.mp3"
            file_type = "audio"
        elif message.photo:
            file = await bot.get_file(message.photo[-1].file_id)
            path = f"temp/{message.from_user.id}_image.jpg"
            file_type = "image"

        if path:
            await bot.download_file(file.file_path, path)
            await state.update_data(**{f"{file_type}_path": path})

        data = await state.get_data()
        content_type = (await state.get_data()).get('content_type')

        if (content_type == 'video' and 'video_path' in data) or \
                (content_type == 'audio_image' and 'audio_path' in data and 'image_path' in data):
            await state.set_state(UploadStates.METADATA)
            await message.answer(
                "üìù –í–≤–µ–¥–∏—Ç–µ –º–µ—Ç–∞–¥–∞–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n<b>–ù–∞–∑–≤–∞–Ω–∏–µ</b>\n<b>–û–ø–∏—Å–∞–Ω–∏–µ</b>\n<b>–¢–µ–≥–∏</b> (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)\n<b>–î–∞—Ç–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏</b> (YYYY-MM-DDTHH:MM:SSZ –∏–ª–∏ '—Å–µ–π—á–∞—Å')",
                parse_mode="HTML"
            )
        else:
            await message.answer("‚ö†Ô∏è –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Ñ–∞–π–ª—ã!")

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@dp.message(UploadStates.METADATA)
async def metadata_handler(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö"""
    try:
        parts = message.text.split('\n')
        metadata = {
            'title': parts[0],
            'description': parts[1],
            'tags': parts[2].split(','),
            'publish_at': parts[3] if len(parts) > 3 else '—Å–µ–π—á–∞—Å'
        }
        await state.update_data(metadata=metadata)
        await message.answer(
            "‚öôÔ∏è –•–æ—Ç–∏—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å VPN/–ü—Ä–æ–∫—Å–∏?",
            reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
                [types.InlineKeyboardButton(text="üõ°Ô∏è –î–∞", callback_data="setup_network")],
                [types.InlineKeyboardButton(text="üöÄ –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_network")]
            ])
        )
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞: {str(e)}\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑")


@dp.callback_query(F.data == "setup_network")
async def setup_network(callback: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Ç–∏"""
    await callback.message.answer(
        "üåê –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:",
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üîê VPN", callback_data="setup_vpn")],
            [types.InlineKeyboardButton(text="üîó –ü—Ä–æ–∫—Å–∏", callback_data="setup_proxy")]
        ])
    )
    await callback.answer()


@dp.callback_query(F.data == "setup_vpn")
async def setup_vpn(callback: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ VPN"""
    await callback.message.answer(
        "üìé –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª –∫–æ–Ω—Ñ–∏–≥–∞ VPN –∏ —É–∫–∞–∂–∏—Ç–µ —Ç–∏–ø –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n<code>—Ç–∏–ø;–Ω–∞–∑–≤–∞–Ω–∏–µ</code>\n–ü—Ä–∏–º–µ—Ä:\n<code>openvpn;–ú–æ–π VPN</code>",
        parse_mode="HTML"
    )
    await state.set_state(UploadStates.VPN_CONFIG)
    await callback.answer()


@dp.message(UploadStates.VPN_CONFIG, F.document)
async def vpn_config_handler(message: types.Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–Ω—Ñ–∏–≥–∞ VPN"""
    try:
        vpn_type, name = message.caption.split(';')
        file = await bot.get_file(message.document.file_id)
        path = f"temp/{message.from_user.id}_vpn.conf"
        await bot.download_file(file.file_path, path)

        with open(path, 'rb') as f:
            encrypted = fernet.encrypt(f.read())

        await update_user_data(message.from_user.id, {f"vpn:{name}": encrypted.decode()})
        await message.answer(f"‚úÖ VPN '{name}' —Å–æ—Ö—Ä–∞–Ω–µ–Ω!")
        os.unlink(path)

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@dp.callback_query(F.data == "setup_proxy")
async def setup_proxy(callback: types.CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–∫—Å–∏"""
    await callback.message.answer(
        "üîó –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–∫—Å–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n<code>—Ç–∏–ø://–ª–æ–≥–∏–Ω:–ø–∞—Ä–æ–ª—å@—Ö–æ—Å—Ç:–ø–æ—Ä—Ç</code>\n–ü—Ä–∏–º–µ—Ä:\n<code>socks5://user123:pass456@1.2.3.4:1080</code>",
        parse_mode="HTML"
    )
    await state.set_state(UploadStates.PROXY)
    await callback.answer()


@dp.message(UploadStates.PROXY)
async def proxy_handler(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–æ–∫—Å–∏"""
    try:
        if not message.text.startswith(('http://', 'https://', 'socks5://')):
            raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ–∫—Å–∏")

        encrypted = fernet.encrypt(message.text.encode()).decode()
        await update_user_data(message.from_user.id, {"proxy": encrypted})
        await message.answer("‚úÖ –ü—Ä–æ–∫—Å–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!")

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


@dp.callback_query(F.data == "skip_network")
async def skip_network(callback: types.CallbackQuery, state: FSMContext):
    """–ü—Ä–æ–ø—É—Å–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Ç–∏"""
    await callback.message.answer("üìé –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª YouTube —Ç–æ–∫–µ–Ω–∞ (JSON)")
    await state.set_state(UploadStates.YOUTUBE_TOKEN)
    await callback.answer()


@dp.message(UploadStates.YOUTUBE_TOKEN, F.document)
async def token_handler(message: types.Message, state: FSMContext, bot: Bot):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–æ–∫–µ–Ω–∞ YouTube"""
    try:
        file = await bot.get_file(message.document.file_id)
        path = f"temp/{message.from_user.id}_token.json"
        await bot.download_file(file.file_path, path)

        with open(path, 'rb') as f:
            encrypted = fernet.encrypt(f.read())

        await update_user_data(message.from_user.id, {"youtube_token": encrypted.decode()})
        await message.answer("‚úÖ –¢–æ–∫–µ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω!")
        os.unlink(path)
        await start_upload_process(message, state)

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")


async def start_upload_process(message: types.Message, state: FSMContext):
    """–ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ"""
    try:
        user_data = await get_user_data(message.from_user.id)
        state_data = await state.get_data()

        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–∫—Å–∏
        if 'proxy' in user_data:
            proxy = fernet.decrypt(user_data['proxy'].encode()).decode()
            os.environ.update({
                'HTTP_PROXY': proxy,
                'HTTPS_PROXY': proxy
            })

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ YouTube
        if 'youtube_token' not in user_data:
            raise ValueError("–¢–æ–∫–µ–Ω YouTube –Ω–µ –Ω–∞–π–¥–µ–Ω")

        token = fernet.decrypt(user_data['youtube_token'].encode()).decode()

        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ VPN
        vpn_connected = False
        for key in user_data:
            if key.startswith('vpn:'):
                try:
                    decrypted = fernet.decrypt(user_data[key].encode()).decode()
                    with tempfile.NamedTemporaryFile(delete=False) as f:
                        f.write(decrypted.encode())
                        vpn_path = f.name

                    vpn_type = key.split(':')[1]
                    cmd = ["openvpn", "--config", vpn_path] if vpn_type == "openvpn" \
                        else ["wg-quick", "up", vpn_path]

                    subprocess.run(cmd, check=True, timeout=30)
                    vpn_connected = True
                    break
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è VPN: {e}")
                finally:
                    os.unlink(vpn_path)

        # –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ
        if state_data['content_type'] == 'audio_image':
            video_path = await create_video_from_media(
                state_data['image_path'],
                state_data['audio_path']
            )
        else:
            video_path = state_data['video_path']

        # –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ YouTube
        service = await asyncio.to_thread(build_youtube_service, token)
        video_id = await asyncio.to_thread(upload_video, service, video_path, state_data['metadata'])
        await message.answer(f"‚úÖ –í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ! ID: {video_id}")

    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {str(e)}")
        logger.exception("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏")
    finally:
        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        for file in ['video_path', 'audio_path', 'image_path']:
            if file in state_data:
                Path(state_data[file]).unlink(missing_ok=True)
        await state.clear()


def build_youtube_service(token_path: str):
    """–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞ YouTube"""
    flow = InstalledAppFlow.from_client_secrets_file(
        token_path,
        scopes=["https://www.googleapis.com/auth/youtube.upload"]
    )
    credentials = flow.run_local_server(port=8080)
    return build("youtube", "v3", credentials=credentials)


def upload_video(service, video_path: str, metadata: Dict) -> str:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ –Ω–∞ YouTube"""
    request_body = {
        "snippet": {
            "title": metadata['title'],
            "description": metadata['description'],
            "tags": metadata['tags'],
            "categoryId": "22"
        },
        "status": {
            "privacyStatus": "public",
            "publishAt": metadata.get('publish_at'),
            "selfDeclaredMadeForKids": False
        }
    }

    media_file = MediaFileUpload(video_path, resumable=True)
    request = service.videos().insert(
        part="snippet,status",
        body=request_body,
        media_body=media_file
    )
    response = request.execute()
    return response['id']


async def create_video_from_media(image_path: str, audio_path: str) -> str:
    """–°–æ–∑–¥–∞–Ω–∏–µ –≤–∏–¥–µ–æ –∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ –∞—É–¥–∏–æ"""
    output_path = tempfile.mktemp(suffix=".mp4", dir="temp")
    cmd = [
        "ffmpeg",
        "-loop", "1",
        "-i", image_path,
        "-i", audio_path,
        "-c:v", "libx264",
        "-tune", "stillimage",
        "-c:a", "aac",
        "-b:a", "192k",
        "-pix_fmt", "yuv420p",
        "-shortest",
        "-y", output_path
    ]
    proc = await asyncio.create_subprocess_exec(*cmd)
    await proc.wait()
    return output_path


if __name__ == "__main__":
    try:
        Path("temp").mkdir(exist_ok=True)
        asyncio.run(dp.start_polling(bot))
    except KeyboardInterrupt:
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    finally:
        # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        for f in Path("temp").glob("*"):
            f.unlink(missing_ok=True)